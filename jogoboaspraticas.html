<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Coruja Digital - Boas Pr√°ticas com IA</title>
<style>
    :root { --hud-bg: rgba(255,255,255,.95); }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
        font-family: Arial, sans-serif;
        background: linear-gradient(135deg,#2c3e50 0%,#3498db 50%,#9b59b6 100%);
        overflow: hidden;
        height: 100vh;
    }
    @supports (height: 100dvh) { body { height: 100dvh; } }

    .game-container {
        position: relative;
        width: 100vw;
        height: 100%;
        overflow: hidden;
        touch-action: none;
    }

    .hud {
        position: fixed;
        top: 12px;
        left: 12px;
        z-index: 100;
        background: var(--hud-bg);
        padding: 12px 14px;
        border-radius: 14px;
        box-shadow: 0 4px 20px rgba(0,0,0,.3);
        border: 2px solid #3498db;
        max-width: min(92vw, 420px);
    }
    .row { display: flex; gap: 14px; flex-wrap: wrap; align-items: baseline; }
    .score { font-size: 18px; font-weight: bold; color: #2c3e50; }
    .lives { font-size: 16px; color: #e74c3c; }
    .progress, .speed { font-size: 14px; color: #27ae60; font-weight: bold; }

    .owl {
        position: absolute;
        width: 60px; height: 60px; font-size: 50px;
        z-index: 10;
        will-change: transform;
        left: 0; top: 0;
        filter: drop-shadow(3px 3px 6px rgba(0,0,0,.4));
        user-select: none;
        -webkit-user-drag: none;
    }

    .item-container {
        position: absolute;
        width: 70px; height: 70px;
        border-radius: 50%;
        display: flex; align-items: center; justify-content: center;
        transition: transform .2s ease, opacity .2s ease;
        cursor: pointer;
        animation: itemFloat 2.5s ease-in-out infinite;
        user-select: none;
    }
    .good-container {
        background: linear-gradient(45deg,#27ae60,#2ecc71);
        border: 4px solid #1e8449;
        box-shadow: 0 6px 20px rgba(39,174,96,.5);
    }
    .bad-container {
        background: linear-gradient(45deg,#e74c3c,#c0392b);
        border: 4px solid #922b21;
        box-shadow: 0 6px 20px rgba(231,76,60,.5);
        animation: itemPulse 1.8s ease-in-out infinite;
    }
    .item-icon { font-size: 28px; color: #fff; text-shadow: 2px 2px 4px rgba(0,0,0,.5); }

    @keyframes itemFloat { 0%,100% { transform: translateY(0) rotate(0) } 50% { transform: translateY(-12px) rotate(2deg) } }
    @keyframes itemPulse { 0%,100%{ transform: scale(1) } 50%{ transform: scale(1.1) } }

    .instructions, .game-over, .word-input-modal {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(255,255,255,.98);
        padding: 28px; border-radius: 18px; text-align: center;
        box-shadow: 0 10px 30px rgba(0,0,0,.4);
        z-index: 1000;
    }
    .instructions, .game-over { border: 3px solid #3498db; }
    .game-over { display: none; border-color: #e74c3c; }

    .instructions h2 { color: #2c3e50; margin-bottom: 16px; font-size: 26px; }
    .instructions p { color: #34495e; margin-bottom: 10px; line-height: 1.6; font-size: 16px; }

    .start-btn {
        background: linear-gradient(45deg,#3498db,#2980b9);
        color: #fff; border: none; padding: 14px 28px; border-radius: 28px;
        font-size: 18px; cursor: pointer; transition: transform .2s ease, box-shadow .2s ease;
        box-shadow: 0 4px 15px rgba(52,152,219,.4);
    }
    .start-btn:hover { transform: scale(1.05); box-shadow: 0 6px 20px rgba(52,152,219,.6); }

    .controls {
        position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%);
        background: var(--hud-bg);
        padding: 10px 18px; border-radius: 22px; font-size: 14px; color: #2c3e50;
        box-shadow: 0 4px 15px rgba(0,0,0,.2); z-index: 50;
    }

    .word-input-modal {
        z-index: 2000; display: none; text-align: center;
        width: min(600px, 90vw); border: 3px solid #27ae60;
    }
    .word-input-modal h3 { margin-bottom: 14px; color: #2c3e50; font-size: 20px; }
    .word-input-modal input {
        width: 100%; padding: 14px; border: 2px solid #bdc3c7; border-radius: 10px; font-size: 16px;
        margin-bottom: 16px; outline: none; transition: border-color .3s ease;
    }
    .word-input-modal input:focus { border-color: #27ae60; }
    .suggestions { margin-bottom: 14px; text-align: left; }
    .suggestions h4 { color: #2c3e50; margin-bottom: 6px; font-size: 15px; }
    .suggestion-tags { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px; }
    .suggestion-tag {
        background: #ecf0f1; color: #2c3e50; padding: 6px 12px; border-radius: 14px; font-size: 12px;
        cursor: pointer; transition: all .15s ease; border: 1px solid #bdc3c7; user-select: none;
    }
    .suggestion-tag:hover { background: #3498db; color: #fff; }
    .good-suggestions .suggestion-tag:hover { background: #27ae60; }
    .bad-suggestions .suggestion-tag:hover { background: #e74c3c; }
    .word-input-modal .buttons { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
    .word-input-modal button { padding: 12px 22px; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; }
    .confirm-btn { background: #27ae60; color: #fff; }
    .skip-btn { background: #95a5a6; color: #fff; }

    .word-item {
        position: absolute; background: rgba(255,255,255,.95);
        border: 3px solid; border-radius: 22px; padding: 10px 16px; font-weight: bold;
        max-width: 220px; text-align: center; word-wrap: break-word;
        animation: wordFloat 3.5s ease-in-out infinite; z-index: 5;
        box-shadow: 0 4px 15px rgba(0,0,0,.2);
        user-select: none;
    }
    .positive-word { border-color: #27ae60; color: #1e8449; box-shadow: 0 4px 15px rgba(39,174,96,.4); }
    .negative-word { border-color: #e74c3c; color: #c0392b; box-shadow: 0 4px 15px rgba(231,76,60,.4); }
    @keyframes wordFloat { 0%,100%{ transform: translateY(0) rotate(0) } 33%{ transform: translateY(-10px) rotate(1deg) } 66%{ transform: translateY(-5px) rotate(-1deg) } }

    .mobile-controls {
        position: fixed; bottom: env(safe-area-inset-bottom, 12px); left: 50%; transform: translateX(-50%);
        z-index: 200; display: none; gap: 8px; padding: 6px;
        background: var(--hud-bg); border-radius: 16px; box-shadow: 0 6px 18px rgba(0,0,0,.25);
    }
    .pad-grid {
        display: grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px 60px;
        gap: 6px; align-items: center; justify-items: center;
    }
    .pad-btn {
        width: 60px; height: 60px; border-radius: 14px; border: 2px solid #3498db; background: #ecf0f1;
        font-size: 22px; line-height: 60px; text-align: center; user-select: none; touch-action: manipulation;
    }
    .pad-btn:active { transform: scale(.97); }

    @media (max-width: 900px), (pointer: coarse) {
        .mobile-controls { display: block; }
        .controls { display: none; }
        .hud { top: 8px; left: 8px; }
        .owl { width: 50px; height: 50px; font-size: 40px; }
        .item-container { width: 60px; height: 60px; }
        .item-icon { font-size: 24px; }
    }
</style>
</head>
<body>
<div class="game-container" id="gameArea" aria-label="√Årea do jogo">
    <div class="hud" aria-live="polite">
        <div class="row">
            <div class="score">pontos: <span id="score">0</span></div>
            <div class="lives">vidas: <span id="lives">3</span></div>
            <div class="progress">progresso: <span id="progress">0</span>/2</div>
            <div class="speed">velocidade: <span id="speedMul">1.0√ó</span> (+/‚àí)</div>
        </div>
    </div>

    <div class="instructions" id="instructions" role="dialog" aria-modal="true">
        <h2>ü¶â coruja digital ‚Äî boas pr√°ticas com ia</h2>
        <p><strong>miss√£o:</strong> colete boas pr√°ticas (c√≠rculos verdes) e evite pr√°ticas ruins (c√≠rculos vermelhos).</p>
        <p><strong>controles:</strong> teclas ‚Üë ‚Üì ‚Üê ‚Üí ou wasd. no celular, use o pad. ‚Äú+‚Äù e ‚Äú‚àí‚Äù mudam a velocidade. para remover uma palavra, chegue perto e pressione espa√ßo 3 vezes.</p>
        <p><strong>a cada 2 acertos:</strong> voc√™ poder√° digitar uma palavra. se for uma palavra sua, voc√™ ganha 1 vida extra.</p>
        <p>boa pr√°tica = +15 | ruim = ‚àí1 vida | palavra sugerida = +25 | palavra nova = +50 e +1 vida</p>
        <button class="start-btn" onclick="startGame()">come√ßar</button>
    </div>

    <div class="game-over" id="gameOver" role="dialog" aria-modal="true">
        <h2>miss√£o conclu√≠da</h2>
        <p>pontua√ß√£o final: <span id="finalScore">0</span></p>
        <p id="gameMessage"></p>
        <button class="start-btn" onclick="restartGame()">jogar de novo</button>
    </div>

    <div class="owl" id="owl" aria-label="Coruja">ü¶â</div>

    <div class="controls">use ‚Üë ‚Üì ‚Üê ‚Üí ou wasd | espa√ßo 3√ó perto de uma palavra | ‚Äú+‚Äù/‚Äú‚àí‚Äù ajusta velocidade</div>

    <div class="mobile-controls" id="mobileControls" aria-label="Controles m√≥veis">
        <div class="pad-grid">
            <button class="pad-btn" id="btnUp" aria-label="Cima">‚¨ÜÔ∏è</button>
            <button class="pad-btn" id="btnSpace" aria-label="A√ß√£o">‚®Ä</button>
            <button class="pad-btn" id="btnRight" aria-label="Direita">‚û°Ô∏è</button>

            <button class="pad-btn" id="btnLeft" aria-label="Esquerda">‚¨ÖÔ∏è</button>
            <div style="width:60px;height:60px"></div>
            <div style="width:60px;height:60px"></div>

            <div style="width:60px;height:60px"></div>
            <button class="pad-btn" id="btnDown" aria-label="Baixo">‚¨áÔ∏è</button>
            <div style="width:60px;height:60px"></div>
        </div>
    </div>

    <div class="word-input-modal" id="wordInputModal" role="dialog" aria-modal="true" aria-labelledby="wordPrompt">
        <h3 id="wordPrompt">digite uma boa pr√°tica no uso da ia</h3>

        <div class="suggestions">
            <div class="good-suggestions">
                <h4>üí° sugest√µes de boas pr√°ticas</h4>
                <div class="suggestion-tags" id="goodSuggestions"></div>
            </div>
            <div class="bad-suggestions">
                <h4>‚ö†Ô∏è sugest√µes de pr√°ticas a evitar</h4>
                <div class="suggestion-tags" id="badSuggestions"></div>
            </div>
        </div>

        <input type="text" id="wordInput" placeholder="ex.: pensamento cr√≠tico, validar fontes..." maxlength="40" />
        <div class="buttons">
            <button class="confirm-btn" onclick="confirmWord()">confirmar</button>
            <button class="skip-btn" onclick="skipWord()">pular</button>
        </div>
    </div>
</div>

<script>
(() => {
    const WORDS_PER_PROMPT = 2; // palavra a cada 2 acertos

    class AIOwlGame {
        constructor() {
            this.owl = document.getElementById('owl');
            this.gameContainer = document.getElementById('gameArea');
            this.scoreElement = document.getElementById('score');
            this.livesElement = document.getElementById('lives');
            this.progressElement = document.getElementById('progress');
            this.speedMulElement = document.getElementById('speedMul');

            this.size = { w: window.innerWidth, h: this.gameContainer.clientHeight };
            this.owlPosition = { x: this.size.w / 2 - 30, y: this.size.h / 2 - 30 };
            this.vel = { x: 0, y: 0 };

            this.baseACC = 700;  // px/s¬≤
            this.baseMAX = 200;  // px/s
            this.speedMul = 1.0; // multiplicador ajust√°vel
            this.minMul = 0.4;
            this.maxMul = 2.0;
            this.mulStep = 0.1;

            this.score = 0;
            this.lives = 3;
            this.items = [];
            this.words = [];
            this.gameRunning = false;
            this.keys = {};
            this.waitingForWord = false;
            this.correctCount = 0;
            this.spaceCount = 0;
            this.targetWord = null;
            this.spaceTimeout = null;

            this.userWords = [];
            this.activeWordSet = new Set();
            this.wordSpawnCounts = Object.create(null);

            this.difficulty = 0;
            this.recentHits = [];
            this.lastFrameTime = performance.now();

            this.goodPractices = [
                { icon: '‚úÖ', name: 'Valida√ß√£o cr√≠tica' },
                { icon: 'ü§ù', name: 'Colabora√ß√£o humano-IA' },
                { icon: 'üìö', name: 'Pesquisa complementar' },
                { icon: 'üîç', name: 'Verifica√ß√£o de fontes' },
                { icon: '‚ú®', name: 'Criatividade humana' },
                { icon: 'üí°', name: 'Pensamento cr√≠tico' },
                { icon: 'üìù', name: 'Documenta√ß√£o do processo' },
                { icon: 'üåç', name: 'Diversidade de perspectivas' },
                { icon: 'üé®', name: 'Autoria pr√≥pria' },
                { icon: 'üéØ', name: 'Objetivos claros' },
                { icon: 'üîí', name: 'Prote√ß√£o de dados' },
                { icon: 'üß©', name: 'Colabora√ß√£o √©tica' }
            ];
            this.badPractices = [
                { icon: '‚ùå', name: 'Aceitar sem questionar' },
                { icon: '‚ö†Ô∏è', name: 'Ignorar vieses' },
                { icon: 'üö´', name: 'Dados pessoais expostos' },
                { icon: 'üõë', name: 'N√£o verificar fontes' },
                { icon: 'ü§ñ', name: 'Uso acr√≠tico' },
                { icon: 'üòµ', name: 'Depend√™ncia total' },
                { icon: 'üìâ', name: 'Falta de transpar√™ncia' },
                { icon: 'üîì', name: 'Risco de privacidade' },
                { icon: 'üóëÔ∏è', name: 'Descartar sem an√°lise' },
                { icon: 'üé≠', name: 'Falsifica√ß√£o de autoria' }
            ];

            this.goodSuggestions = [
                'pensamento cr√≠tico','validar fontes','transpar√™ncia','colabora√ß√£o humano-IA',
                'contexto claro','diversidade de perspectivas','criatividade pr√≥pria',
                'documentar processo','uso √©tico','comparar ferramentas','autoavalia√ß√£o',
                'explora√ß√£o investigativa','adapta√ß√£o ao contexto'
            ];
            this.badSuggestions = [
                'aceitar sem questionar','dados pessoais','uso acr√≠tico','ignorar vieses',
                'n√£o verificar evid√™ncias','falta de transpar√™ncia','depend√™ncia total',
                'n√£o indicar IA','uso autom√°tico','descartar conhecimento humano'
            ];

            this.setupSuggestions();
            this.setupEventListeners();
            this.setupMobilePad();
            this.updateSpeedHUD();
        }

        setupSuggestions() {
            const goodContainer = document.getElementById('goodSuggestions');
            const badContainer = document.getElementById('badSuggestions');

            this.goodSuggestions.forEach(s => {
                const tag = document.createElement('span');
                tag.className = 'suggestion-tag';
                tag.textContent = s;
                tag.onclick = () => { document.getElementById('wordInput').value = s; };
                goodContainer.appendChild(tag);
            });
            this.badSuggestions.forEach(s => {
                const tag = document.createElement('span');
                tag.className = 'suggestion-tag';
                tag.textContent = s;
                tag.onclick = () => { document.getElementById('wordInput').value = s; };
                badContainer.appendChild(tag);
            });
        }

        setupEventListeners() {
            window.addEventListener('resize', () => {
                this.size = { w: window.innerWidth, h: this.gameContainer.clientHeight };
                this.owlPosition.x = Math.max(0, Math.min(this.size.w - 60, this.owlPosition.x));
                this.owlPosition.y = Math.max(0, Math.min(this.size.h - 60, this.owlPosition.y));
                this.updateOwlPosition();
            });

            document.addEventListener('visibilitychange', () => {
                if (document.hidden) this.resetKeys();
            });

            document.addEventListener('keydown', (e) => {
                if (['+','=','-','_'].includes(e.key)) {
                    e.preventDefault();
                    if (e.key === '+' || e.key === '=') this.bumpSpeed(1);
                    else this.bumpSpeed(-1);
                    return;
                }

                if (this.waitingForWord) return;

                const k = e.key;
                if (k === ' ' || k === 'Spacebar') {
                    this.handleSpacePress();
                    e.preventDefault();
                    return;
                }
                let key = k.toLowerCase();
                if (key === 'arrowup') key = 'up';
                if (key === 'arrowdown') key = 'down';
                if (key === 'arrowleft') key = 'left';
                if (key === 'arrowright') key = 'right';
                if (['arrowup','arrowdown','arrowleft','arrowright'].includes(k)) e.preventDefault();
                this.keys[key] = true;
            });

            document.addEventListener('keyup', (e) => {
                if (this.waitingForWord) return;
                let key = e.key.toLowerCase();
                if (key === 'arrowup') key = 'up';
                if (key === 'arrowdown') key = 'down';
                if (key === 'arrowleft') key = 'left';
                if (key === 'arrowright') key = 'right';
                this.keys[key] = false;
            });

            let dragging = false;
            this.gameContainer.addEventListener('pointerdown', (e) => {
                const target = e.target;
                if (target.closest('#mobileControls') || target.closest('.hud') || target.closest('.word-input-modal') || target.closest('.instructions') || target.closest('.game-over')) return;
                dragging = true;
                this.moveOwlToPointer(e);
            });
            this.gameContainer.addEventListener('pointermove', (e) => {
                if (dragging && !this.waitingForWord) this.moveOwlToPointer(e);
            });
            window.addEventListener('pointerup', () => dragging = false);

            document.getElementById('wordInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') { confirmWord(); }
            });
        }

        setupMobilePad() {
            const map = [
                { id: 'btnUp', key: 'up' },
                { id: 'btnDown', key: 'down' },
                { id: 'btnLeft', key: 'left' },
                { id: 'btnRight', key: 'right' },
                { id: 'btnSpace', key: 'space' }
            ];
            map.forEach(({ id, key }) => {
                const btn = document.getElementById(id);
                if (!btn) return;

                const start = (e) => {
                    e.preventDefault();
                    if (key === 'space') {
                        this.handleSpacePress();
                    } else {
                        this.keys[key] = true;
                    }
                };
                const end = (e) => {
                    e.preventDefault();
                    if (key !== 'space') this.keys[key] = false;
                };

                btn.addEventListener('pointerdown', start);
                btn.addEventListener('pointerup', end);
                btn.addEventListener('pointercancel', end);
                btn.addEventListener('pointerleave', end);
            });
        }

        moveOwlToPointer(e) {
            const rect = this.gameContainer.getBoundingClientRect();
            const x = e.clientX - rect.left - 30;
            const y = e.clientY - rect.top - 30;
            this.owlPosition.x = Math.max(0, Math.min(this.size.w - 60, x));
            this.owlPosition.y = Math.max(0, Math.min(this.size.h - 60, y));
            this.updateOwlPosition();
            this.vel.x = 0; this.vel.y = 0;
        }

        resetKeys() { this.keys = {}; }

        bumpSpeed(dir) {
            this.speedMul = Math.max(this.minMul, Math.min(this.maxMul, +(this.speedMul + dir * this.mulStep).toFixed(2)));
            this.updateSpeedHUD();
        }

        updateSpeedHUD() {
            this.speedMulElement.textContent = this.speedMul.toFixed(1) + '√ó';
        }

        start() {
            this.gameRunning = true;
            this.score = 0;
            this.lives = 3;
            this.items = [];
            this.words = [];
            this.userWords = [];
            this.activeWordSet.clear();
            this.wordSpawnCounts = Object.create(null);
            this.owlPosition = { x: this.size.w / 2 - 30, y: this.size.h / 2 - 30 };
            this.vel = { x: 0, y: 0 };
            this.waitingForWord = false;
            this.correctCount = 0;
            this.spaceCount = 0;
            this.targetWord = null;
            this.difficulty = 0;
            this.recentHits = [];
            this.lastFrameTime = performance.now();

            this.updateHUD();
            this.updateOwlPosition();
            document.querySelectorAll('.item-container, .word-item').forEach(n => n.remove());

            this.gameLoop();
            this.scheduleNextSpawn();
            this.spawnUserWords();
        }

        gameLoop() {
            if (!this.gameRunning) return;

            const now = performance.now();
            const dt = Math.min(32, now - this.lastFrameTime);
            this.lastFrameTime = now;

            if (!this.waitingForWord) {
                this.handleMovement(dt);
                this.checkCollisions();
                this.moveItems(dt);
                this.moveWords(dt);
            }
            requestAnimationFrame(() => this.gameLoop());
        }

        // movimento com acelera√ß√£o, atrito e corre√ß√£o anti-grude nas bordas
        handleMovement(dt){
            const t = dt / 1000;
            const isCoarse = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);

            const ACC       = (isCoarse ? 600 : this.baseACC) * this.speedMul;
            const MAX_SPEED = (isCoarse ? 160 : this.baseMAX) * this.speedMul;
            const DAMPING   = 8.0;

            const pressingLeft  = this.keys['left']  || this.keys['a'];
            const pressingRight = this.keys['right'] || this.keys['d'];
            const pressingUp    = this.keys['up']    || this.keys['w'];
            const pressingDown  = this.keys['down']  || this.keys['s'];

            let ax = 0, ay = 0;
            if (pressingLeft)  ax -= ACC;
            if (pressingRight) ax += ACC;
            if (pressingUp)    ay -= ACC;
            if (pressingDown)  ay += ACC;

            this.vel.x += ax * t;
            this.vel.y += ay * t;

            const damp = Math.exp(-DAMPING * t);
            if (!pressingLeft && !pressingRight) this.vel.x *= damp;
            if (!pressingUp   && !pressingDown)  this.vel.y *= damp;

            const spd = Math.hypot(this.vel.x, this.vel.y);
            if (spd > MAX_SPEED){
                const k = MAX_SPEED / spd;
                this.vel.x *= k; this.vel.y *= k;
            }

            let nx = this.owlPosition.x + this.vel.x * t;
            let ny = this.owlPosition.y + this.vel.y * t;

            const maxX = this.size.w - 60;
            const maxY = this.size.h - 60;

            // anti-grude: leve afastamento da parede mesmo sem input horizontal/vertical
            const EPS = 0.2;     // deslocamento m√≠nimo para n√£o ficar cravado no limite
            const RELEASE = 1.0; // empurr√£o quando a tecla oposta est√° pressionada

            // eixo X
            if (nx < 0) {
                nx = 0;
                if (this.vel.x < 0) this.vel.x = 0; // corta empurr√£o contra parede
                nx += (pressingRight ? RELEASE : EPS);
            } else if (nx > maxX) {
                nx = maxX;
                if (this.vel.x > 0) this.vel.x = 0;
                nx -= (pressingLeft ? RELEASE : EPS);
            }

            // eixo Y
            if (ny < 0) {
                ny = 0;
                if (this.vel.y < 0) this.vel.y = 0;
                ny += (pressingDown ? RELEASE : EPS);
            } else if (ny > maxY) {
                ny = maxY;
                if (this.vel.y > 0) this.vel.y = 0;
                ny -= (pressingUp ? RELEASE : EPS);
            }

            this.owlPosition.x = Math.max(0, Math.min(maxX, nx));
            this.owlPosition.y = Math.max(0, Math.min(maxY, ny));
            this.updateOwlPosition();
        }

        updateOwlPosition() {
            this.owl.style.transform = `translate3d(${this.owlPosition.x}px, ${this.owlPosition.y}px, 0)`;
        }

        getGoodChance() {
            const base = 0.80;
            const reduction = this.difficulty * 0.12;
            return Math.max(0.38, base - reduction);
        }
        getItemLifetime() {
            return Math.max(6500, 10000 - this.difficulty * 2000);
        }
        getSpawnInterval() {
            const baseMin = 1100, baseMax = 2200;
            const delta = this.difficulty * 250;
            const min = Math.max(700, baseMin - delta);
            const max = Math.max(min + 200, baseMax - delta);
            return Math.random() * (max - min) + min;
        }
        getSpeed(isGood) {
            const bump = this.difficulty * 0.4;
            return isGood ? (Math.random() * 2 + 1 + bump) : (Math.random() * 1.2 + 0.5 + bump * 0.6);
        }

        scheduleNextSpawn() {
            if (!this.gameRunning) return;
            this.spawnItem();
            setTimeout(() => this.scheduleNextSpawn(), this.getSpawnInterval());
        }

        spawnItem() {
            if (!this.gameRunning) return;

            const isGood = Math.random() < this.getGoodChance();
            const itemData = isGood
                ? this.goodPractices[Math.floor(Math.random() * this.goodPractices.length)]
                : this.badPractices[Math.floor(Math.random() * this.badPractices.length)];

            const container = document.createElement('div');
            container.className = `item-container ${isGood ? 'good-container' : 'bad-container'}`;
            const icon = document.createElement('div');
            icon.className = 'item-icon';
            icon.textContent = itemData.icon;
            container.appendChild(icon);
            container.title = itemData.name;

            const x = Math.random() * (this.size.w - 70);
            const y = Math.random() * (this.size.h - 70);
            container.style.left = x + 'px';
            container.style.top = y + 'px';

            container.dataset.type = isGood ? 'good' : 'bad';
            container.dataset.speed = String(this.getSpeed(isGood));
            container.dataset.direction = String(Math.random() * Math.PI * 2);

            this.gameContainer.appendChild(container);
            this.items.push(container);

            setTimeout(() => {
                if (container.parentNode) {
                    container.remove();
                    this.items = this.items.filter(i => i !== container);
                }
            }, this.getItemLifetime());
        }

        moveItems(dt) {
            const factor = dt / 16.67;
            this.items.forEach(item => {
                if (!item.parentNode) return;

                let speed = parseFloat(item.dataset.speed) * factor;
                let dir = parseFloat(item.dataset.direction);

                let x = parseFloat(item.style.left);
                let y = parseFloat(item.style.top);

                let nx = x + Math.cos(dir) * speed;
                let ny = y + Math.sin(dir) * speed;

                if (nx <= 0 || nx >= this.size.w - 70) { dir = Math.PI - dir; }
                if (ny <= 0 || ny >= this.size.h - 70) { dir = -dir; }

                item.dataset.direction = String(dir);
                item.style.left = Math.max(0, Math.min(this.size.w - 70, nx)) + 'px';
                item.style.top  = Math.max(0, Math.min(this.size.h - 70, ny)) + 'px';
            });
        }

        moveWords(dt) {
            const factor = dt / 16.67;
            this.words.forEach(word => {
                if (!word.parentNode) return;

                let speed = parseFloat(word.dataset.speed) * factor;
                let dir = parseFloat(word.dataset.direction);

                let x = parseFloat(word.style.left);
                let y = parseFloat(word.style.top);

                let nx = x + Math.cos(dir) * speed;
                let ny = y + Math.sin(dir) * speed;

                if (nx <= 0 || nx >= this.size.w - 220) { dir = Math.PI - dir; }
                if (ny <= 0 || ny >= this.size.h - 60) { dir = -dir; }

                word.dataset.direction = String(dir);
                word.style.left = Math.max(0, Math.min(this.size.w - 220, nx)) + 'px';
                word.style.top  = Math.max(0, Math.min(this.size.h - 60, ny)) + 'px';
            });
        }

        checkCollisions() {
            const owlRect = this.owl.getBoundingClientRect();

            this.items.slice().forEach(item => {
                if (!item.parentNode) return;
                const rect = item.getBoundingClientRect();
                if (this.isColliding(owlRect, rect)) this.handleItemCollision(item);
            });

            this.words.slice().forEach(word => {
                if (!word.parentNode) return;
                const rect = word.getBoundingClientRect();
                if (this.isColliding(owlRect, rect)) this.handleWordCollision(word);
            });
        }

        isColliding(r1, r2) {
            return !(r1.right < r2.left || r1.left > r2.right || r1.bottom < r2.top || r1.top > r2.bottom);
        }

        handleItemCollision(item) {
            const isGood = item.dataset.type === 'good';

            if (isGood) {
                this.score += 15;
                this.correctCount++;
                item.style.transform = 'scale(1.5)';
                item.style.opacity = '0';

                this.recentHits.push(true);
                if (this.recentHits.length > 10) this.recentHits.shift();

                if (this.correctCount % WORDS_PER_PROMPT === 0) {
                    this.requestWord();
                }
            } else {
                this.lives--;
                this.recentHits.push(false);
                if (this.recentHits.length > 10) this.recentHits.shift();

                this.owl.style.filter = 'hue-rotate(180deg)';
                setTimeout(() => {
                    this.owl.style.filter = 'drop-shadow(3px 3px 6px rgba(0,0,0,.4))';
                }, 250);
            }

            item.remove();
            this.items = this.items.filter(i => i !== item);
            this.adjustDifficulty();
            this.updateHUD();

            if (this.lives <= 0) this.endGame();
        }

        handleWordCollision(word) {
            const isPositive = word.dataset.type === 'positive';
            this.score = Math.max(0, this.score + (isPositive ? 8 : -8));

            const text = word.dataset.text;
            this.activeWordSet.delete(text);

            word.style.transform = 'scale(1.4)';
            word.style.opacity = '0';
            word.remove();
            this.words = this.words.filter(w => w !== word);
            this.updateHUD();
        }

        handleSpacePress() {
            const nearby = this.findNearbyWord();
            if (!nearby) return;

            if (this.targetWord === nearby) {
                this.spaceCount++;
                if (this.spaceTimeout) clearTimeout(this.spaceTimeout);

                nearby.style.transform = `scale(${1 + this.spaceCount * .15})`;
                nearby.style.opacity = `${1 - this.spaceCount * .25}`;

                if (this.spaceCount >= 3) {
                    const text = nearby.dataset.text;
                    this.activeWordSet.delete(text);

                    nearby.remove();
                    this.words = this.words.filter(w => w !== nearby);
                    this.resetSpaceCounter();
                } else {
                    this.spaceTimeout = setTimeout(() => this.resetSpaceCounter(), 2000);
                }
            } else {
                this.resetSpaceCounter();
                this.targetWord = nearby;
                this.spaceCount = 1;
                nearby.style.transform = 'scale(1.15)';
                nearby.style.opacity = '0.75';
                this.spaceTimeout = setTimeout(() => this.resetSpaceCounter(), 2000);
            }
        }

        findNearbyWord() {
            const owlRect = this.owl.getBoundingClientRect();
            const ox = (owlRect.left + owlRect.right) / 2;
            const oy = (owlRect.top + owlRect.bottom) / 2;
            const threshold = 90;

            for (const word of this.words) {
                const r = word.getBoundingClientRect();
                const wx = (r.left + r.right) / 2;
                const wy = (r.top + r.bottom) / 2;
                const d = Math.hypot(ox - wx, oy - wy);
                if (d < threshold) return word;
            }
            return null;
        }

        resetSpaceCounter() {
            this.spaceCount = 0;
            this.targetWord = null;
            if (this.spaceTimeout) { clearTimeout(this.spaceTimeout); this.spaceTimeout = null; }
            this.words.forEach(w => { w.style.transform = 'scale(1)'; w.style.opacity = '1'; });
        }

        requestWord() {
            this.waitingForWord = true;
            const modal = document.getElementById('wordInputModal');
            const input = document.getElementById('wordInput');
            input.value = '';
            modal.style.display = 'block';
            setTimeout(() => input.focus(), 50);
        }

        isWordInSuggestions(word) {
            const t = word.trim().toLowerCase();
            return this.goodSuggestions.some(s => s.toLowerCase() === t)
                || this.badSuggestions.some(s => s.toLowerCase() === t);
        }

        addWordToScreen(word, isPositive) {
            const key = word.trim().toLowerCase();
            if (!key) return;
            if (this.activeWordSet.has(key)) return;

            const prev = this.wordSpawnCounts[key] || 0;
            const newCount = prev + 1;
            this.wordSpawnCounts[key] = newCount;

            const baseSize = 14;
            const sizeBump = Math.min(6, newCount);
            const fontSize = baseSize + sizeBump;

            const el = document.createElement('div');
            el.className = `word-item ${isPositive ? 'positive-word' : 'negative-word'}`;
            el.textContent = word;
            el.style.fontSize = fontSize + 'px';

            const x = Math.random() * (this.size.w - 220);
            const y = Math.random() * (this.size.h - 60);
            el.style.left = x + 'px';
            el.style.top = y + 'px';

            el.dataset.type = isPositive ? 'positive' : 'negative';
            el.dataset.speed = String(Math.random() * 1.5 + 0.8 + this.difficulty * 0.3);
            el.dataset.direction = String(Math.random() * Math.PI * 2);
            el.dataset.text = key;

            this.gameContainer.appendChild(el);
            this.words.push(el);
            this.activeWordSet.add(key);
        }

        spawnUserWords() {
            if (!this.gameRunning) return;

            const spawn = () => {
                if (!this.gameRunning) return;
                if (this.userWords.length > 0) {
                    const w = this.userWords[Math.floor(Math.random() * this.userWords.length)];
                    this.addWordToScreen(w.text, w.isPositive);
                }
                const next = Math.random() * 6000 + 12000; // 12‚Äì18 s
                setTimeout(spawn, next);
            };

            setTimeout(spawn, 8000);
        }

        updateHUD() {
            this.scoreElement.textContent = this.score;
            this.livesElement.textContent = this.lives;
            this.progressElement.textContent = this.correctCount % WORDS_PER_PROMPT;
        }

        adjustDifficulty() {
            if (this.recentHits.length < 8) return;
            const acc = this.recentHits.reduce((a,b)=>a+(b?1:0),0) / this.recentHits.length;
            if (acc >= 0.85 && this.difficulty < 3) this.difficulty++;
            else if (acc <= 0.60 && this.difficulty > 0) this.difficulty--;
        }

        endGame() {
            this.gameRunning = false;
            this.waitingForWord = false;
            document.getElementById('wordInputModal').style.display = 'none';
            document.getElementById('finalScore').textContent = this.score;

            let msg = '';
            if (this.score >= 150) msg = '√≥timo dom√≠nio das boas pr√°ticas.';
            else if (this.score >= 75) msg = 'bom desempenho. continue explorando o uso √©tico.';
            else msg = 'siga praticando. o uso respons√°vel melhora com treino.';

            document.getElementById('gameMessage').textContent = msg;
            document.getElementById('gameOver').style.display = 'block';

            document.querySelectorAll('.item-container, .word-item').forEach(n => n.remove());
            this.activeWordSet.clear();
        }
    }

    window.game = new AIOwlGame();

    window.startGame = function() {
        document.getElementById('instructions').style.display = 'none';
        game.start();
    };
    window.restartGame = function() {
        document.getElementById('gameOver').style.display = 'none';
        game.start();
    };
    window.confirmWord = function() {
        const input = document.getElementById('wordInput');
        const textRaw = input.value;
        const text = textRaw.trim();
        if (text) {
            const isPositive = !game.badSuggestions.some(bad =>
                text.toLowerCase().includes(bad.toLowerCase()) || bad.toLowerCase().includes(text.toLowerCase())
            );
            const isNew = !game.isWordInSuggestions(text);
            const points = isNew ? 50 : 25;

            game.score += points;
            if (isNew) { game.lives += 1; }
            game.updateHUD();

            game.userWords.push({ text, isPositive, isNew });
            game.addWordToScreen(text, isPositive);
        }
        window.closeWordModal();
    };
    window.skipWord = function() { window.closeWordModal(); };
    window.closeWordModal = function() {
        document.getElementById('wordInputModal').style.display = 'none';
        game.waitingForWord = false;
    };
})();
</script>
</body>
</html>
